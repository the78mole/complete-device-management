---
# Master Docker Compose – Cloud Infrastructure (local evaluation)
# Bring up: docker compose up -d
# Prerequisites: copy .env.example to .env and fill in secrets

networks:
  cdm-internal:
    driver: bridge
  cdm-vpn:
    driver: bridge

volumes:
  keycloak-db-data:
  thingsboard-data:
  thingsboard-logs:
  thingsboard-db-data:
  tb-mqtt-certs:
  hawkbit-db-data:
  hawkbit-data:
  influxdb-data:
  influxdb-config:
  grafana-data:
  wg-data:
  rabbitmq-data:
  step-ca-data:

secrets:
  step-ca-password:
    file: ./step-ca/password.txt

# ─────────────────────────── Keycloak ────────────────────────────
services:
  # ─────────────────────── Step CA (PKI) ──────────────────────────
  # step-ca auto-creates a Root CA + Intermediate CA on first boot
  # using the DOCKER_STEPCA_INIT_* variables below.
  # All values are configurable via .env (see .env.example).
  step-ca:
    build:
      context: ./step-ca
      dockerfile: Dockerfile
    container_name: cdm-step-ca
    restart: unless-stopped
    environment:
      # ── Root CA ──────────────────────────────────────────────────
      # Human-readable name embedded in the Root CA subject
      DOCKER_STEPCA_INIT_NAME: "${STEP_CA_PKI_NAME:-CDM Root CA}"
      # Comma-separated DNS names the CA certificate is valid for
      DOCKER_STEPCA_INIT_DNS_NAMES: "${STEP_CA_DNS_NAMES:-step-ca,localhost}"
      # ── Intermediate CA ──────────────────────────────────────────
      # step-ca signs the intermediate CA with the root during init;
      # the password file protects both the root and intermediate keys.
      # Validity of the root and intermediate CA certificates is set
      # via the step ca init flags (see init-provisioners.sh).
      DOCKER_STEPCA_INIT_PASSWORD_FILE: /run/secrets/step-ca-password
      # TLS address the CA HTTPS API listens on
      DOCKER_STEPCA_INIT_ADDRESS: "${STEP_CA_ADDRESS:-:9000}"
      # ── Provisioner setup ────────────────────────────────────────
      # Name/email of the first (bootstrap) admin JWK provisioner
      DOCKER_STEPCA_INIT_PROVISIONER_NAME: "${STEP_CA_ADMIN_PROVISIONER:-cdm-admin@cdm.local}"
      # Enable ACME provisioner (for automatic device cert renewal)
      DOCKER_STEPCA_INIT_ACME: "${STEP_CA_ENABLE_ACME:-true}"
      # Enable the Admin API so init-provisioners.sh can add more provisioners
      DOCKER_STEPCA_INIT_REMOTE_MANAGEMENT: "${STEP_CA_ENABLE_REMOTE_MGMT:-true}"
      # Disable SSH CA (not needed for this IoT platform)
      DOCKER_STEPCA_INIT_SSH: "${STEP_CA_ENABLE_SSH:-false}"
    secrets:
      - step-ca-password
    volumes:
      - step-ca-data:/home/step
    ports:
      - "9000:9000"
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD", "step", "ca", "health", "--ca-url", "https://localhost:9000", "--root", "/home/step/certs/root_ca.crt"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 30s

  keycloak-db:
    image: postgres:18-alpine
    container_name: cdm-keycloak-db
    restart: unless-stopped
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: ${KC_DB_PASSWORD:-changeme}
    volumes:
      - keycloak-db-data:/var/lib/postgresql/data
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U keycloak"]
      interval: 10s
      timeout: 5s
      retries: 5

  keycloak:
    build:
      context: ./keycloak
      dockerfile: Dockerfile
    container_name: cdm-keycloak
    restart: unless-stopped
    command: >
      start-dev
      --import-realm
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://keycloak-db:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: ${KC_DB_PASSWORD:-changeme}
      KEYCLOAK_ADMIN: ${KC_ADMIN_USER:-admin}
      KEYCLOAK_ADMIN_PASSWORD: ${KC_ADMIN_PASSWORD:-changeme}
      KC_HTTP_PORT: 8080
      KC_HOSTNAME_STRICT: "false"
      KC_HTTP_RELATIVE_PATH: /auth
      # Trust X-Forwarded-* headers from reverse proxies (e.g. GitHub Codespaces,
      # nginx). Without this Keycloak builds redirect URLs using the internal
      # hostname:port instead of the external proxy URL.
      KC_PROXY_HEADERS: xforwarded
      # KC_HOSTNAME_STRICT_HTTPS is a deprecated v1 hostname option (KC 26+).
      # Leaving it out avoids issuer-mismatch 403s when clients access KC over
      # HTTPS (Codespaces). KC_PROXY_HEADERS=xforwarded already handles this.
      # OIDC client secrets – interpolated into realm JSON files by docker-entrypoint.sh
      TB_OIDC_SECRET: ${TB_OIDC_SECRET:-changeme}
      GRAFANA_OIDC_SECRET: ${GRAFANA_OIDC_SECRET:-changeme}
      HB_OIDC_SECRET: ${HB_OIDC_SECRET:-changeme}
      BRIDGE_OIDC_SECRET: ${BRIDGE_OIDC_SECRET:-changeme}
      PORTAL_OIDC_SECRET: ${PORTAL_OIDC_SECRET:-changeme}
      INFLUX_PROXY_OIDC_SECRET: ${INFLUX_PROXY_OIDC_SECRET:-changeme}
      GRAFANA_BROKER_SECRET: ${GRAFANA_BROKER_SECRET:-changeme}
      # Realm bootstrap user passwords
      PROVIDER_OPERATOR_PASSWORD: ${PROVIDER_OPERATOR_PASSWORD:-changeme}
      TENANT1_ADMIN_PASSWORD: ${TENANT1_ADMIN_PASSWORD:-changeme}
      TENANT1_OPERATOR_PASSWORD: ${TENANT1_OPERATOR_PASSWORD:-changeme}
      TENANT1_VIEWER_PASSWORD: ${TENANT1_VIEWER_PASSWORD:-changeme}
      TENANT2_ADMIN_PASSWORD: ${TENANT2_ADMIN_PASSWORD:-changeme}
      TENANT2_OPERATOR_PASSWORD: ${TENANT2_OPERATOR_PASSWORD:-changeme}
      TENANT2_VIEWER_PASSWORD: ${TENANT2_VIEWER_PASSWORD:-changeme}
    ports:
      - "8080:8080"
    networks:
      - cdm-internal
    depends_on:
      keycloak-db:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "exec 3<>/dev/tcp/localhost/8080 && printf 'GET /auth/realms/master HTTP/1.0\\r\\nHost: localhost\\r\\n\\r\\n' >&3 && timeout 5 grep -q 200 <&3"]
      interval: 20s
      timeout: 10s
      retries: 10
      start_period: 90s

  # ──────────────────────── ThingsBoard ────────────────────────────
  thingsboard-db:
    image: postgres:18-alpine
    container_name: cdm-tb-db
    restart: unless-stopped
    environment:
      POSTGRES_DB: thingsboard
      POSTGRES_USER: thingsboard
      POSTGRES_PASSWORD: ${TB_DB_PASSWORD:-changeme}
    volumes:
      - thingsboard-db-data:/var/lib/postgresql/data
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U thingsboard"]
      interval: 10s
      timeout: 5s
      retries: 5

  thingsboard:
    image: thingsboard/tb-postgres:4.2.1
    container_name: cdm-thingsboard
    restart: unless-stopped
    environment:
      TB_QUEUE_TYPE: in-memory
      SPRING_DATASOURCE_URL: jdbc:postgresql://thingsboard-db:5432/thingsboard
      SPRING_DATASOURCE_USERNAME: thingsboard
      SPRING_DATASOURCE_PASSWORD: ${TB_DB_PASSWORD:-changeme}
      # Keycloak OIDC
      SECURITY_OAUTH2_ENABLED: "true"
      SECURITY_OAUTH2_DEFAULT_PROVIDER: keycloak
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_CLIENT_ID: thingsboard
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_CLIENT_SECRET: ${TB_OIDC_SECRET:-changeme}
      # AUTH_URI is browser-facing – must use EXTERNAL_URL so Codespaces browsers can reach Keycloak
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_AUTHORIZATION_URI: ${EXTERNAL_URL:-http://localhost:8888}/auth/realms/cdm/protocol/openid-connect/auth
      # TOKEN/USERINFO/JWKS are server-to-server calls – use internal hostname
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_TOKEN_URI: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/token
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_USER_INFO_URI: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/userinfo
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_JWKS_URI: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/certs
      # REDIRECT_URI is browser-facing – Keycloak redirects here after login (port 9090, not 8888)
      SECURITY_OAUTH2_REGISTRATION_KEYCLOAK_REDIRECT_URI: ${TB_EXTERNAL_URL:-http://localhost:9090}/login/oauth2/code/
      # ── MQTT TLS / X.509 client-certificate authentication ────────────────
      # Devices connect on port 8883 and present the certificate signed by step-ca.
      # The root CA cert is read from the step-ca-data volume at the path below.
      MQTT_SSL_ENABLED: "${MQTT_SSL_ENABLED:-false}"
      MQTT_SSL_BIND_ADDRESS: "0.0.0.0"
      MQTT_SSL_BIND_PORT: "8883"
      # MQTT server certificate and key are stored in the tb-mqtt-certs named volume.
      # Generate them ONCE after step-ca has initialised (init-provisioners.sh has run):
      #
      #   docker exec cdm-step-ca \
      #     step ca certificate mqtt.cdm.local \
      #       /home/step/mqttserver.pem /home/step/mqttserver-private.pem \
      #       --provisioner iot-bridge --not-after 8760h --force
      #
      #   docker exec cdm-step-ca cat /home/step/mqttserver.pem \
      #     | docker exec -i cdm-thingsboard sh -c 'cat > /etc/tb-certs/mqttserver.pem'
      #   docker exec cdm-step-ca cat /home/step/mqttserver-private.pem \
      #     | docker exec -i cdm-thingsboard sh -c 'cat > /etc/tb-certs/mqttserver-private.pem'
      #
      # Then set MQTT_SSL_ENABLED=true in .env and restart ThingsBoard:
      #   docker compose restart thingsboard
      MQTT_SSL_CREDENTIALS_TYPE: PEM
      MQTT_SSL_PEM_CERT: /etc/tb-certs/mqttserver.pem
      MQTT_SSL_PEM_KEY: /etc/tb-certs/mqttserver-private.pem
      MQTT_SSL_PEM_KEY_PASSWORD: ""
      # Require client certificates (mTLS) – devices must present a cert signed by step-ca
      MQTT_SSL_CLIENT_AUTHENTICATION: "${MQTT_SSL_CLIENT_AUTHENTICATION:-NONE}"
      # Trust only certs signed by the CDM Root CA (from step-ca-data volume)
      MQTT_SSL_TRUSTSTORE_PATH: /step-ca-certs/certs/root_ca.crt
      MQTT_SSL_TRUSTSTORE_TYPE: PEM
    volumes:
      - thingsboard-data:/data
      - thingsboard-logs:/var/log/thingsboard
      # Read step-ca root CA cert for MQTT TLS truststore
      - step-ca-data:/step-ca-certs:ro
      # MQTT server certificate (operator must run provision.sh to generate)
      - tb-mqtt-certs:/etc/tb-certs
    ports:
      - "9090:9090"   # HTTP UI
      - "1883:1883"   # MQTT plain (for local dev without TLS)
      - "8883:8883"   # MQTT TLS with X.509 client-cert authentication
      - "7070:7070"   # Edge
    networks:
      - cdm-internal
    depends_on:
      thingsboard-db:
        condition: service_healthy
      keycloak:
        condition: service_healthy

  # ───────────────────────── hawkBit ───────────────────────────────
  # RabbitMQ is required by hawkBit's DMF (Device Management Federation) bus.
  # Even if you only use the DDI (HTTP polling) API, the hawkbit-update-server
  # image unconditionally loads its AmqpConfiguration and needs a live broker.
  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: cdm-rabbitmq
    restart: unless-stopped
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_ADMIN_USER:-admin}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_ADMIN_PASSWORD:-changeme}
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq
      - ./rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 10

  hawkbit-db:
    image: mysql:8-debian
    container_name: cdm-hawkbit-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: hawkbit
      MYSQL_USER: hawkbit
      MYSQL_PASSWORD: ${HB_DB_PASSWORD:-changeme}
      MYSQL_ROOT_PASSWORD: ${HB_DB_ROOT_PASSWORD:-changeme_root}
    volumes:
      - hawkbit-db-data:/var/lib/mysql
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "hawkbit", "--password=${HB_DB_PASSWORD:-changeme}"]
      interval: 10s
      timeout: 5s
      retries: 10

  hawkbit:
    image: hawkbit/hawkbit-update-server:latest
    container_name: cdm-hawkbit
    restart: unless-stopped
    environment:
      HB_DB_PASSWORD: ${HB_DB_PASSWORD:-changeme}
      HB_OIDC_SECRET: ${HB_OIDC_SECRET:-changeme}
      # RabbitMQ connection for the hawkBit DMF event bus
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_RABBITMQ_PORT: "5672"
      SPRING_RABBITMQ_USERNAME: ${RABBITMQ_ADMIN_USER:-admin}
      SPRING_RABBITMQ_PASSWORD: ${RABBITMQ_ADMIN_PASSWORD:-changeme}
      # server.port in application.properties is overridden by the bundled default;
      # env vars have the highest precedence in Spring Boot.
      SERVER_PORT: "8070"
      # Sub-path for the nginx reverse proxy
      SERVER_SERVLET_CONTEXT_PATH: /hawkbit
    volumes:
      - ./hawkbit/application.properties:/opt/hawkbit/application.properties:ro
      - hawkbit-data:/data
    ports:
      - "8070:8070"
    networks:
      - cdm-internal
    depends_on:
      hawkbit-db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      keycloak:
        condition: service_healthy

  # ───────────────────────── InfluxDB ──────────────────────────────
  influxdb:
    image: influxdb:2.8-alpine
    container_name: cdm-influxdb
    restart: unless-stopped
    environment:
      DOCKER_INFLUXDB_INIT_MODE: setup
      DOCKER_INFLUXDB_INIT_USERNAME: ${INFLUX_ADMIN_USER:-admin}
      DOCKER_INFLUXDB_INIT_PASSWORD: ${INFLUX_ADMIN_PASSWORD:-changeme00}
      DOCKER_INFLUXDB_INIT_ORG: cdm-org
      DOCKER_INFLUXDB_INIT_BUCKET: iot-metrics
      DOCKER_INFLUXDB_INIT_ADMIN_TOKEN: ${INFLUX_TOKEN:-my-super-secret-influx-token}
    volumes:
      - influxdb-data:/var/lib/influxdb2
      - influxdb-config:/etc/influxdb2
      - ./monitoring/influxdb/init-scripts:/docker-entrypoint-initdb.d:ro
    networks:
      - cdm-internal
    healthcheck:
      test: ["CMD", "influx", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    depends_on:
      keycloak:
        condition: service_healthy

  # ──────────────────── InfluxDB OAuth2 Proxy ──────────────────────
  # oauth2-proxy enforces Keycloak login before the InfluxDB web UI.
  # Only users with the cdm-admin or cdm-operator realm role are granted
  # access. The proxy listens on port 4180, exposed as host port 8086 so
  # the landing page link stays unchanged.
  #
  # InfluxDB API paths (/api/v2/, /write, /query, /ping, /health) bypass
  # authentication – service-to-service calls (iot-bridge-api, telegraf)
  # use InfluxDB API tokens on the internal Docker network and are
  # unaffected.
  influxdb-proxy:
    image: quay.io/oauth2-proxy/oauth2-proxy:v7.8.1
    container_name: cdm-influxdb-proxy
    restart: unless-stopped
    environment:
      OAUTH2_PROXY_PROVIDER: oidc
      # Internal URL for server-side OIDC discovery, token exchange and JWKS.
      # The browser never sees this hostname.
      OAUTH2_PROXY_OIDC_ISSUER_URL: http://keycloak:8080/auth/realms/cdm
      # Override the authorization endpoint with the external (browser-facing) URL.
      # Without this, oauth2-proxy would hand the browser the internal
      # keycloak:8080 URL from OIDC discovery → ERR_NAME_NOT_RESOLVED.
      OAUTH2_PROXY_LOGIN_URL: ${EXTERNAL_URL:-http://localhost:8888}/auth/realms/cdm/protocol/openid-connect/auth
      # Keep token redemption and JWKS on the internal network.
      OAUTH2_PROXY_REDEEM_URL: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/token
      OAUTH2_PROXY_OIDC_JWKS_URL: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/certs
      OAUTH2_PROXY_CLIENT_ID: influxdb-proxy
      OAUTH2_PROXY_CLIENT_SECRET: ${INFLUX_PROXY_OIDC_SECRET:-changeme}
      # Browser-facing callback URL – uses port 8086 (not 8888) like ThingsBoard
      # Codespaces: https://<name>-8086.app.github.dev
      # Local:      http://localhost:8086
      OAUTH2_PROXY_REDIRECT_URL: ${INFLUX_EXTERNAL_URL:-http://localhost:8086}/oauth2/callback
      OAUTH2_PROXY_UPSTREAMS: http://influxdb:8086
      # Permit any Keycloak-verified identity; roles claim gates access
      OAUTH2_PROXY_EMAIL_DOMAINS: "*"
      # The influxdb-proxy Keycloak client has a realm-roles ProtocolMapper
      # that injects a flat "roles" array claim. cdm-viewer is excluded –
      # Grafana already covers read-only dashboard access.
      OAUTH2_PROXY_OIDC_GROUPS_CLAIM: roles
      OAUTH2_PROXY_ALLOWED_GROUPS: cdm-admin,cdm-operator
      # Include roles scope so the claim is present in the token
      OAUTH2_PROXY_SCOPE: "openid profile email roles"
      # Skip the auth flow for all InfluxDB API and health paths so that
      # service tokens from iot-bridge-api / telegraf pass through unchanged.
      OAUTH2_PROXY_SKIP_AUTH_ROUTES: "^/api/,^/write,^/query,^/ping,^/health,^/metrics"
      # Cookie settings – SECURE must be false over plain HTTP (local dev)
      OAUTH2_PROXY_COOKIE_SECRET: ${INFLUX_PROXY_COOKIE_SECRET:-0123456789abcdef0123456789abcdef}
      OAUTH2_PROXY_COOKIE_SECURE: "false"
      OAUTH2_PROXY_HTTP_ADDRESS: 0.0.0.0:4180
      OAUTH2_PROXY_REVERSE_PROXY: "true"
    ports:
      - "8086:4180"
    networks:
      - cdm-internal
    depends_on:
      keycloak:
        condition: service_healthy
      influxdb:
        condition: service_healthy

  # ───────────────────────── Grafana ───────────────────────────────
  grafana:
    image: grafana/grafana-oss:12.3.3
    container_name: cdm-grafana
    restart: unless-stopped
    environment:
      GF_SERVER_ROOT_URL: "%(protocol)s://%(domain)s/grafana/"
      GF_SERVER_SERVE_FROM_SUB_PATH: "true"
      GF_AUTH_GENERIC_OAUTH_ENABLED: "true"
      GF_AUTH_GENERIC_OAUTH_NAME: Keycloak
      GF_AUTH_GENERIC_OAUTH_CLIENT_ID: grafana
      GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET: ${GRAFANA_OIDC_SECRET:-changeme}
      GF_AUTH_GENERIC_OAUTH_SCOPES: openid profile email roles
      GF_AUTH_GENERIC_OAUTH_ALLOW_SIGN_UP: "true"
      GF_AUTH_GENERIC_OAUTH_USE_REFRESH_TOKEN: "true"
      # AUTH_URL is browser-facing – must be reachable from the user's browser.
      # In Codespaces set EXTERNAL_URL=https://<name>-8888.app.github.dev in .env
      GF_AUTH_GENERIC_OAUTH_AUTH_URL: ${EXTERNAL_URL:-http://localhost:8888}/auth/realms/cdm/protocol/openid-connect/auth
      GF_AUTH_GENERIC_OAUTH_TOKEN_URL: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/token
      GF_AUTH_GENERIC_OAUTH_API_URL: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/userinfo
      # Map Keycloak realm roles → Grafana roles (JMESPath against userinfo)
      GF_AUTH_GENERIC_OAUTH_ROLE_ATTRIBUTE_PATH: "contains(roles[*], 'cdm-admin') && 'Admin' || contains(roles[*], 'cdm-operator') && 'Editor' || 'Viewer'"
      GF_AUTH_GENERIC_OAUTH_ROLE_ATTRIBUTE_STRICT: "false"
      # Redirect directly to Keycloak login (skip Grafana login page)
      GF_AUTH_OAUTH_AUTO_LOGIN: "true"
      # Redirect to Keycloak logout when signing out of Grafana
      GF_AUTH_SIGNOUT_REDIRECT_URL: "${EXTERNAL_URL:-http://localhost:8888}/auth/realms/cdm/protocol/openid-connect/logout?client_id=grafana&post_logout_redirect_uri=${EXTERNAL_URL:-http://localhost:8888}/grafana/login"
      GF_AUTH_ANONYMOUS_ENABLED: "false"
      GF_SECURITY_ALLOW_EMBEDDING: "true"
      GF_INSTALL_PLUGINS: grafana-clock-panel,grafana-simple-json-datasource
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards:ro
    ports:
      - "3000:3000"
    networks:
      - cdm-internal
    depends_on:
      influxdb:
        condition: service_healthy
      keycloak:
        condition: service_healthy

  # ───────────────────────── WireGuard ─────────────────────────────
  wireguard:
    image: lscr.io/linuxserver/wireguard:latest
    container_name: cdm-wireguard
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    environment:
      PUID: 1000
      PGID: 1000
      TZ: UTC
      SERVERURL: ${WG_SERVER_URL:-auto}
      SERVERPORT: ${WG_PORT:-51820}
      PEERS: ${WG_PEERS:-10}
      PEERDNS: auto
      INTERNAL_SUBNET: 10.13.13.0
      ALLOWEDIPS: 10.13.13.0/24
    volumes:
      - wg-data:/config
      - /lib/modules:/lib/modules:ro
    ports:
      - "51820:51820/udp"
    networks:
      - cdm-internal
      - cdm-vpn
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    restart: unless-stopped
    depends_on:
      keycloak:
        condition: service_healthy


  # ──────────────────── IoT Bridge API (glue) ──────────────────────
  iot-bridge-api:
    build:
      context: ../glue-services/iot-bridge-api
      dockerfile: Dockerfile
    container_name: cdm-iot-bridge-api
    restart: unless-stopped
    environment:
      KEYCLOAK_URL: http://keycloak:8080/auth
      KEYCLOAK_REALM: cdm
      KEYCLOAK_CLIENT_ID: iot-bridge
      KEYCLOAK_CLIENT_SECRET: ${BRIDGE_OIDC_SECRET:-changeme}
      # Tenant portal settings
      EXTERNAL_URL: ${EXTERNAL_URL:-http://localhost:8888}
      PORTAL_OIDC_SECRET: ${PORTAL_OIDC_SECRET:-changeme}
      PORTAL_SESSION_SECRET: ${PORTAL_SESSION_SECRET:-change-this-portal-session-secret}
      PORTAL_TENANTS_JSON: '{"cdm":{"name":"CDM Platform"},"tenant1":{"name":"Acme Devices GmbH"},"tenant2":{"name":"Beta Industries Ltd"}}'
      # RabbitMQ Management API (for admin portal tenant provisioning)
      RABBITMQ_MGMT_URL: http://rabbitmq:15672
      RABBITMQ_ADMIN_USER: ${RABBITMQ_ADMIN_USER:-admin}
      RABBITMQ_ADMIN_PASSWORD: ${RABBITMQ_ADMIN_PASSWORD:-changeme}
      # Keycloak admin credentials (for dynamic realm creation)
      KEYCLOAK_ADMIN_USER: ${KC_ADMIN_USER:-admin}
      KEYCLOAK_ADMIN_PASSWORD: ${KC_ADMIN_PASSWORD:-changeme}
      # step-ca admin provisioner (JWK password = contents of step-ca/password.txt)
      STEP_CA_ADMIN_PROVISIONER: ${STEP_CA_ADMIN_PROVISIONER:-cdm-admin@cdm.local}
      STEP_CA_ADMIN_PASSWORD: ${STEP_CA_ADMIN_PASSWORD:-changeme}
      THINGSBOARD_URL: http://thingsboard:9090
      THINGSBOARD_SYSADMIN_EMAIL: ${TB_SYSADMIN_EMAIL:-sysadmin@thingsboard.org}
      THINGSBOARD_SYSADMIN_PASSWORD: ${TB_SYSADMIN_PASSWORD:-sysadmin}
      HAWKBIT_URL: http://hawkbit:8070/hawkbit
      HAWKBIT_USER: ${HB_ADMIN_USER:-admin}
      HAWKBIT_PASSWORD: ${HB_ADMIN_PASSWORD:-admin}
      INFLUX_URL: http://influxdb:8086
      INFLUX_TOKEN: ${INFLUX_TOKEN:-my-super-secret-influx-token}
      INFLUX_ORG: cdm-org
      INFLUX_BUCKET: iot-metrics
      WIREGUARD_CONFIG_DIR: /wg-config
      WG_SUBNET: 10.13.13.0/24
      WG_SERVER_IP: 10.13.13.1
      STEP_CA_URL: https://step-ca:9000
      STEP_CA_FINGERPRINT: ${STEP_CA_FINGERPRINT:-}
      STEP_CA_PROVISIONER_NAME: ${STEP_CA_PROVISIONER_NAME:-iot-bridge}
      STEP_CA_PROVISIONER_PASSWORD: ${STEP_CA_PROVISIONER_PASSWORD:-changeme}
      STEP_CA_VERIFY_TLS: ${STEP_CA_VERIFY_TLS:-false}
      # Sub-path prefix for nginx reverse proxy (/api/)
      ROOT_PATH: /api
    volumes:
      - wg-data:/wg-config
    ports:
      - "8000:8000"
    networks:
      - cdm-internal
    depends_on:
      keycloak:
        condition: service_healthy
      thingsboard:
        condition: service_started
      hawkbit:
        condition: service_started
      step-ca:
        condition: service_healthy

  # ───────────────── Cloud-side Telegraf (metrics aggregator) ─────────
  # Collects device metrics from hawkBit (OTA/update status) and subscribes
  # to tenant-scoped MQTT topics for optional additional sensor data.
  # Primary ThingsBoard device telemetry is forwarded to InfluxDB by the
  # iot-bridge-api /webhooks/thingsboard/telemetry endpoint (rule chain).
  #
  # Tenant isolation is enforced via:
  #   – hawkBit data tagged with HAWKBIT_TENANT
  #   – MQTT topics: cdm/<tenant>/<device>/sensors
  #   – InfluxDB tags: tenant_id, device_id on every data point
  telegraf:
    image: telegraf:1.37-alpine
    container_name: cdm-telegraf
    restart: unless-stopped
    environment:
      INFLUX_URL: http://influxdb:8086
      INFLUX_TOKEN: ${INFLUX_TOKEN:-my-super-secret-influx-token}
      INFLUX_ORG: cdm-org
      INFLUX_BUCKET: iot-metrics
      HAWKBIT_URL: http://hawkbit:8070/hawkbit
      HAWKBIT_USER: ${HB_ADMIN_USER:-admin}
      HAWKBIT_PASSWORD: ${HB_ADMIN_PASSWORD:-admin}
      HAWKBIT_TENANT: ${HB_TENANT:-DEFAULT}
      THINGSBOARD_HOST: thingsboard
    volumes:
      - ./monitoring/telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:ro
    networks:
      - cdm-internal
    depends_on:
      - influxdb
      - hawkbit
      - thingsboard

  # ─────────────────────── Terminal Proxy ──────────────────────────
  terminal-proxy:
    build:
      context: ../glue-services/terminal-proxy
      dockerfile: Dockerfile
    container_name: cdm-terminal-proxy
    restart: unless-stopped
    environment:
      TTYD_PORT: 7681
      VPN_SUBNET: 10.13.13.0/24
      AUTH_JWKS_URI: http://keycloak:8080/auth/realms/cdm/protocol/openid-connect/certs
      AUTH_AUDIENCE: terminal-proxy
      # Path to cdm_peers.json written by iot-bridge-api (shared volume)
      PEERS_DB_PATH: /wg-config/cdm_peers.json
    volumes:
      - wg-data:/wg-config:ro
    ports:
      - "8090:8090"
    networks:
      - cdm-internal
      - cdm-vpn
    depends_on:
      wireguard:
        condition: service_started
      keycloak:
        condition: service_healthy

  # ─────────────────────── nginx (reverse proxy) ───────────────────
  # Single entry point on port 8888.  All services reachable by prefix:
  #   /            → Landing page   /auth/     → Keycloak
  #   /grafana/    → Grafana        /hawkbit/  → hawkBit
  #   /hawkbit/    → hawkBit        /api/      → IoT Bridge API
  #   /terminal/   → Terminal Proxy
  #
  # Codespaces: https://<name>-8888.app.github.dev/
  # Local:      http://localhost:8888/
  nginx:
    image: nginx:1.27-alpine
    container_name: cdm-nginx
    restart: unless-stopped
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/html:/usr/share/nginx/html:ro
    ports:
      - "8888:8888"
    networks:
      - cdm-internal
    depends_on:
      keycloak:
        condition: service_healthy
      thingsboard:
        condition: service_started
      grafana:
        condition: service_started
      hawkbit:
        condition: service_started
      iot-bridge-api:
        condition: service_started
      terminal-proxy:
        condition: service_started
      step-ca:
        condition: service_healthy
      influxdb-proxy:
        condition: service_started
      rabbitmq:
        condition: service_healthy
