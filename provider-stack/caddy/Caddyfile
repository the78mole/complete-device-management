# CDM Provider Stack – Caddyfile
#
# Caddy replaces nginx as the reverse proxy.  Out of the box it handles:
#   - Automatic HTTPS via ACME (Let's Encrypt / ZeroSSL) in production
#   - HTTP-only mode for local dev / GitHub Codespaces (CADDY_AUTO_HTTPS=off)
#
# DEPLOYMENT MODES
#
#   Development / Codespaces (default):
#     CADDY_SITE_ADDRESS=   (empty → listens on :8888, all interfaces, plain HTTP)
#     CADDY_AUTO_HTTPS=off
#
#   Production (real domain + Let's Encrypt):
#     CADDY_SITE_ADDRESS=cdm.example.com   ← Caddy requests LE cert for this domain
#     CADDY_AUTO_HTTPS=on
#     Expose ports 80 + 443 in docker-compose.yml (for ACME HTTP-01 challenge)
#
# Service routing:
#   /           → Landing page (static)
#   /auth/      → Keycloak          keycloak:8080
#   /grafana/   → Grafana           grafana:3000
#   /api/       → IoT Bridge API    iot-bridge-api:8000  (strips /api prefix)
#   /rabbitmq/  → RabbitMQ Mgmt     rabbitmq:15672
#   /pki/       → step-ca           step-ca:9000 (HTTPS upstream)

{
    # auto_https off  → plain HTTP (dev / Codespaces)
    # auto_https on   → Let's Encrypt / ZeroSSL (production, requires real domain)
    auto_https {$CADDY_AUTO_HTTPS:off}
    # ACME e-mail for Let's Encrypt notifications (set via CADDY_ACME_EMAIL in .env)
    email {$CADDY_ACME_EMAIL:}
    admin off
}

# CADDY_SITE_ADDRESS controls both the listen address and HTTPS cert domain:
#   empty / unset → :8888  (all interfaces, port 8888, plain HTTP)
#   cdm.example.com → port 443, automatic Let's Encrypt cert
{$CADDY_SITE_ADDRESS::8888} {

    # ── Keycloak (/auth/) ─────────────────────────────────────────────────
    # Keycloak is configured with KC_HTTP_RELATIVE_PATH=/auth so it already
    # serves everything under /auth/.  We forward the path unchanged.
    # Large header buffers are required for Keycloak's JWT-bearing Set-Cookie.
    handle /auth/* {
        reverse_proxy keycloak:8080 {
            # Buffer large Keycloak response headers (JWTs, CSP, etc.)
            header_down -Server
            flush_interval -1
            # Ensure Keycloak sees the correct external protocol/port,
            # even when VS Code port-forwarding or Codespaces sets its own
            # X-Forwarded-Port / X-Forwarded-Proto headers upstream.
            header_up X-Forwarded-Proto {scheme}
            header_up X-Forwarded-Host  {host}
            header_up -X-Forwarded-Port
        }
    }

    # ── Grafana (/grafana/) ───────────────────────────────────────────────
    # GF_SERVER_SERVE_FROM_SUB_PATH=true means Grafana handles the /grafana/
    # prefix itself; we forward the full path unchanged.
    handle /grafana/* {
        reverse_proxy grafana:3000
    }

    # ── IoT Bridge API (/api/) ────────────────────────────────────────────
    # FastAPI is configured with ROOT_PATH=/api (affects OpenAPI schema URLs).
    # The actual HTTP server handles requests at /, so we strip /api before
    # forwarding.
    handle /api/* {
        uri strip_prefix /api
        reverse_proxy iot-bridge-api:8000
    }

    # ── RabbitMQ Management (/rabbitmq/) ──────────────────────────────────
    # management.path_prefix=/rabbitmq in rabbitmq.conf makes the plugin serve
    # all assets and API calls under /rabbitmq/.
    handle /rabbitmq/* {
        reverse_proxy rabbitmq:15672
    }

    # ── step-ca PKI API (/pki/) ───────────────────────────────────────────
    # step-ca exposes a pure HTTPS API; there is no web UI.
    # Useful endpoints: GET /pki/health  GET /pki/root/<fingerprint>
    handle /pki/* {
        uri strip_prefix /pki
        reverse_proxy https://step-ca:9000 {
            transport http {
                tls_insecure_skip_verify  # step-ca root CA not in Caddy trust store
            }
        }
    }

    # ── Landing page (/) ─────────────────────────────────────────────────
    handle {
        root * /srv/html
        file_server
        try_files {path} /index.html
    }
}
